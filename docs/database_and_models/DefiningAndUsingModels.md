# Defining and using models

A model is defined as file under the `src/models` path. It must export a table schema definition and may optionally export definitions for virtual fields, model methods and document instance methods.


## Schema 

At a bare minimum our model must export a `schema`:

```javascript
// file: <project folder>/src/models/user.js

const ProfileSchema = {
  displayName: { 
    type: String, 
    required: true 
  },
};

exports.schema = {
  username: { 
    type: String, 
    required: true,
  },
  password: { 
    type: String, 
    required: true,
  },
  profile: { 
    type: ProfileSchema, 
    required: false,
  },
  lastLogin: { 
    type: Date, 
    required: false,
  },
};
```

_Note: Thinodium uses the [simple-nosql-schema](https://github.com/hiddentao/simple-nosql-schema) module to validate schemas. Check it out to find out about the different types and options possible for each field defined in the schema_.

The above schema specifies four fields for the database table - `username`, `password`, `profile` and `lastLogin` - with the first two fields being mandatory for any new rows that are to be inserted into the table. The `profile` field value is a nested document which must contain atleast a `displayName` key. The `lastLogin` field is of type `Date` meaning that in the database it is stored as a date timestamp.

Using this model is simple:

```javascript
// file: <project folder>/src/controllers/index.js

exports.add = function*() {
  let user = yield this.App.models.User.insert({
  	username: 'test@test.com',
  	password: 'password',
  	profile: {
	  displayName: 'test user'
  	}
  });
  
  this.body = user.username;	// test@test.com
}
```

We can fetch all rows at any time:

```javascript
// ...continuing from previous example...

let allUsers = yield this.App.models.User.getAll();

/* allUsers.length === 1 */

console.log( allUsers[0].username );	  /* test@test.com */
```


Every database table row has a unique `id` field (the primary key) which is auto-generated by the database engine. This can be used to quickly fetch an item we've previously inserted:

```javascript
// ...continuing from previous example...

// reload user from db
let addedUser = yield this.App.models.User.get(user.id);
```

We can update a user's attributes:

```javascript
// ...continuing from previous example...

// update username
user.username = 'test2@domain.com';
yield user.save();
```

We can also remove the user.

```javascript
// ...continuing from previous example...

yield user.remove();

let addedUser = yield this.App.models.User.get(user.id);

/* addedUser === null */
```

_Note: Read the [Thinodium docs](https://hiddentao.github.io/thinodium) for the full model API._

## Indexes

To speed up lookups on heavily-used tables we can and should add _indexes_:

```javascript
// file: <project folder>/src/models/user.js

exports.schema = {
  username: { 
    type: String, 
    required: true,
  },
  password: { 
    type: String, 
    required: true,
  },
  roles: { 
    type: [String], 
    required: false,
  },  
};

exports.indexes = {
  {
    name: 'username',
  },
  {
    name: 'roles',
    options: {
      multi: true,
    },
  },    
};
```

We've asked for two indexes - one on the `username` field and one on the `roles` field with the additonal setting that it should be treated as being able to hold multiple values (because `roles` specifies an array of strings). 

From now on lookup by username and/or role will be quicker than before.

_Note: More complex compound indexes are supported - check out Waigo's built-in models for real examples._

## Primary key

By default the `id` field (which is auto-defined by the database engine) is assumed to the primary key. But you can override this setting using the `pk` export:

```javascript
// file: <project folder>/src/models/user.js

exports.pk = 'username';
```

## Model methods

Model methods are the methods available on the model object itself. There are a number of built-in methods - `get()`, `insert()`, etc - provided by Waigo. But it is a good idea to add custom methods as a convenience and in order to control access.

For example, let's say we wish to hash a new user's password before inserting it. We will provide an `add()` method to add a user, and a `load()` method to fetch a user given username and password:

```javascript
// file: <project folder>/src/models/user.js

const waigo = require('waigo'),
	_ = waigo._;	// lodash

exports.schema = {
  username: { 
    type: String, 
    required: true,
  },
  password: { 
    type: String, 
    required: true,
  },
};

exports.modelMethods = {
  add: function*(username, password) {
    this._logger.info(`Adding user: ${username}`);
    
    return this.insert({
      username: username,
      password: someHashingFunction(password),
    });
  },
  
  load: function*(username, password) {
    this._logger.info(`Loading user: ${username}`);
    
    password = someHashingFunction(password);
    
    let ret = yield this.rawQry().filter(function(user) {
      return user('password').eq(password).and(user('username').eq(username));
    }).run();
    
    this.wrapRaw(_.get(ret, '0'));
  }
};
```
The `_logger()` method we used inside the model methods gives us access to a [logger](../logging) associated with the Model - it is auto-created by Waigo. We can also access the `App` object at any time using the `_App()` method, though in this case we didn't need to do this. 

The `rawQry()` method is available on all Waigo models and enables the raw querying mode for our underlying database table. In this case it's the same as executing a query using [rethinkdbdash](https://github.com/neumino/rethinkdbdash), the RethinkDB database library that is being used at a lower level.

The `wrapRaw()` method wraps raw database data (as returned by using `rawQry()`) in our models' document instances (see [Thinodium docs](https://hiddentao.github.io/thinodium)).

We would use this model as follows:

```javascript
yield App.models.User.add('test@test.com', 'password');

// let's try loading, but with a wrong password
let user = App.models.User.load('test@test.com', 'wrongpassword');

/* user === null */

// let's try loading with right password
user = App.models.User.load('test@test.com', 'password');

console.log(user.password);  /* F24FA5B... some hash */
```

Notice above that `user.password` returns the hashed version of the password. Thus we wouldn't be able to manually compare a password which the user has input with the the one in the documented returned by the model.

We can work around this using document methods.

## Document methods

Document methods are extra methods to enable on the document instances returned by our Model's data retrieval methods.

_Note: Waigo automatically adds `_App()` and `_logger()` methods to every document instance, same as for Model objects_.

The `getById()` method is automatically available to on model instances. Beyond that a model must define its own additional methods within the `Model` class itself.

In our example model we have defined two: `getByUsername` and `register`.

You'll notice that within our example we call a couple of internal methods: `_qry()` and `_insert()`. These are provided by the `RethinkDBModel` base class and perform the actual work of talking to the database and processing results.

The available internal methods are:

* `_qry()` - construct a RethinkDB query object - basically `r.table('table name')`.
* `_insert()` - insert a new record and return a document instance.
* `_update()` - update a record.
* `_remove()` - remove a record.
* `_get()` - equivalent to RethinkDb's [get()](https://www.rethinkdb.com/api/javascript/#get).
* `_getAll()` - equivalent to RethinkDb's [get()](https://www.rethinkdb.com/api/javascript/#getAll).
* `_wrap()` - process query results array (or single result object) by encapsulating each raw query result in a document instance.
* `_createDoc()` - encapsulate given raw query result in a document instance (this gets called by `_wrap()`).

These internal methods give you all the tools you need to build out model and document methods.


**Document methods**

Document methods are the methods available on an instance of a "document" returned by the model.


**Virtual fields**

Virtual fields are fields which appear in the Model's interface as normal fields but which aren't actually stored in the database. They're essentially another way of doing model instance methods.


The `TABLE_DEF` constant defines the database schema, database indexes and _virtual_ fields.
